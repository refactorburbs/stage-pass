// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// New feature: to speed up queries and scale with serverless/edge functions:
// We are using Prisma Accelerate: https://pris.ly/cli/accelerate-init

/**
 * FOR REFERENCE - A PostgreSQL database was created from the Refactor Games
 * Prisma.io console - see our website's admin page for credentials.
 * --- Next steps ---
 * Go to https://pris.ly/ppg-init for detailed instructions.
 * 1. Define your database schema
 * Open the schema.prisma file and define your first models. Check the docs if you need inspiration: https://pris.ly/ppg-init.
 * 2. Apply migrations
 * Run the following command to create and apply a migration:
 * npx prisma migrate dev --name init
 * 3. Manage your data
 * View and edit your data locally by running this command:
 * npx prisma studio
 * 4. Send queries from your app
 * To access your database from a JavaScript/TypeScript app, you need to use Prisma ORM. Go here for step-by-step instructions: https://pris.ly/ppg-init
 */

// More instructions on setting up schema and seeding the db: https://www.prisma.io/docs/guides/nextjs
// Seed command: npx prisma db seed

// To view your database tables, run:
// npx prisma studio

// To update database tables, you need to create a migration and name it:
// npx prisma migrate dev --name nameOfMigration

// To completely wipe everything and start over:
// 1. Delete the entirety of the migrations folder
// 2. npx prisma migrate reset --force (you'll see an error, it's ok ignore it)
// 3. npx prisma migrate dev --name init
// 4. seed the database: npx prisma db seed

// In production, it is recommended to use the command:
// prisma generate --no-engine
// This is already configured into the build script for this website, so all you have to do is run
// npm run build

generator client {
  provider = "prisma-client-js"
  output   = "../app/generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Enums
enum UserRole {
  LEAD // can vote, comment, upload (phase 1) - higher vote weight
  ARTIST // can upload and comment
  VOTER // can vote and comment (phase 1 OR phase 2 final say if also game owner)
}

enum AssetStatus {
  PENDING // Initial state
  PHASE1_APPROVED // Approved in internal review
  PHASE1_REJECTED // Rejected in internal review
  PHASE2_APPROVED // Final approval from owners
  PHASE2_REJECTED // Final rejection from owners
  ARCHIVED // Moved to archive after final decision
  REVISED // A marker for assets that are closed from comments and voting
}

enum VoteType {
  APPROVE
  REJECT
}

// Only assets within the category "Full Asset" move on to phase 2
enum VotePhase {
  PHASE1 // Internal review (teams + leads + voters)
  PHASE2 // Owner review (only owners vote)
}

enum SubscriptionType {
  VOTED    // User subscribed by voting on the asset
  COMMENTED // User subscribed by commenting on the asset
  UPLOADED // LEAD or ARTIST who uploaded a specific asset
}

// Teams (companies working on games)
model Team {
  id        Int      @id @default(autoincrement())
  name      String   @unique // Company name (e.g., "Netflix", "EA Sports", "Outsourcer A")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations where team_id is a FK in other tables
  users       User[]
  gameTeams   GameTeam[]
  inviteCodes InviteCode[]

  @@map("teams")
}

model Game {
  id              Int      @id @default(autoincrement())
  name            String
  assetCategories String[] // ["Heads", "Cleats", "Clothing", "Tattoos", "Full Asset"]

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations where game_id is a FK in other tables
  gameTeams        GameTeam[]
  gameOwners       GameOwner[] // Junction table for game-specific ownership
  assets           Asset[]
  lockJobs         AssetPendingLock[]

  @@map("games")
}

// Junction table for many-to-many relationship between games and teams
model GameTeam {
  id         Int       @id @default(autoincrement())
  game_id    Int
  team_id    Int

  // Active team tracking - some teams may not work the duration of the game
  startedAt  DateTime  @default(now()) @map("started_at")
  endedAt    DateTime? @map("ended_at")

  // Relations
  game Game @relation(fields: [game_id], references: [id], onDelete: Cascade)
  team Team @relation(fields: [team_id], references: [id], onDelete: Cascade)

  @@unique([game_id, team_id])
  @@map("game_teams")
}

// Invite codes that pre-populate user signup with team, role, and game access
model InviteCode {
  id           Int      @id @default(autoincrement())
  code         String   @unique
  team_id      Int
  role         UserRole // Role the user will get when they sign up
  description  String? // e.g., "Refactor Artist", "Netflix Owner Voter"
  ownedGameIds Int[]    @map("owned_game_ids")
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")

  // Relations
  team  Team   @relation(fields: [team_id], references: [id], onDelete: Cascade)
  users User[] // Track who used this invite code

  @@map("invite_codes")
}

model User {
  id           Int       @id @default(autoincrement())
  firstName    String
  lastName     String
  fullName     String
  initials     String
  email        String    @unique
  passwordHash String
  avatar       Int       @default(0) // 0-4 for predefined colored avatars with initials
  customAvatar String?   // URL for uploaded avatar
  role         UserRole // Base role, but can be overridden by game-specific ownership
  isActive     Boolean   @default(true)
  lastLogin    DateTime? @map("last_login")
  team_id       Int
  invite_code_id Int? // Track which invite code was used
  createdAt    DateTime  @default(now()) @map("created_at")
  updatedAt    DateTime  @updatedAt @map("updated_at")

  // Relations
  team               Team                   @relation(fields: [team_id], references: [id], onDelete: Cascade)
  inviteCode         InviteCode?            @relation(fields: [invite_code_id], references: [id])
  gameOwners         GameOwner[] // Games where this user is an owner
  uploadedAssets     Asset[]                @relation("AssetUploader")
  votes              AssetVote[]
  comments           AssetComment[]
  assetSubscriptions AssetSubscription[]
  pendingCommentNotifications PendingCommentNotification[]

  @@map("users")
}

// Game-specific ownership (users can be owners of some games but not others)
model GameOwner {
  id      Int @id @default(autoincrement())
  game_id Int
  user_id Int

  createdAt DateTime @default(now()) @map("created_at")

  // Relations
  game Game @relation(fields: [game_id], references: [id], onDelete: Cascade)
  user User @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@unique([game_id, user_id])
  @@map("game_owners")
}

model Asset {
  id          Int    @id @default(autoincrement())
  title       String
  category    String // Must be one of the categories from the associated game
  imageUrl    String

  // Status and phase tracking
  status               AssetStatus @default(PENDING)
  currentPhase         VotePhase   @default(PHASE1)

  // Foreign Keys
  game_id     Int
  uploader_id Int

  // Timestamps
  createdAt         DateTime @default(now()) @map("created_at")
  updatedAt         DateTime @updatedAt @map("updated_at")
  phase1CompletedAt DateTime? @map("phase1_completed_at")
  phase2CompletedAt DateTime? @map("phase2_completed_at")

  // Relations
  game             Game                   @relation(fields: [game_id], references: [id], onDelete: Cascade)
  uploader         User                   @relation("AssetUploader", fields: [uploader_id], references: [id], onDelete: Cascade)
  votes            AssetVote[]
  comments         AssetComment[]
  subscriptions    AssetSubscription[]
  notifications    PendingCommentNotification[]
  lockJob          AssetPendingLock?

  @@index([game_id, status, currentPhase]) // For filtering assets by game and phase
  @@index([status, currentPhase]) // For dashboard queries
  @@map("assets")
}

// Votes can be on either original assets or revisions, and in different phases
model AssetVote {
  id        Int       @id @default(autoincrement())
  voteType  VoteType
  phase     VotePhase
  weight    Decimal       @default(1.0) // LEADs get a slightly higher weight than VOTERs

  // Foreign Keys
  asset_id Int
  user_id   Int

  // Timestamp
  createdAt DateTime  @default(now()) @map("created_at")

  // Relations
  user     User       @relation(fields: [user_id], references: [id], onDelete: Cascade)
  asset    Asset      @relation(fields: [asset_id], references: [id], onDelete: Cascade)

  @@unique([asset_id, user_id, phase]) // Prevent duplicate votes per phase
  @@index([asset_id, phase]) // For counting votes per asset/phase
  @@index([user_id]) // For user's voting history
  @@map("votes")
}

model AssetComment {
  id        Int       @id @default(autoincrement())
  content   String

  // Foreign Keys
  asset_id  Int
  user_id   Int

  // Timestamp
  createdAt DateTime  @default(now()) @map("created_at")

  // Relations
  user     User       @relation(fields: [user_id], references: [id], onDelete: Cascade)
  asset    Asset      @relation(fields: [asset_id], references: [id], onDelete: Cascade)

  notifications PendingCommentNotification[]
}

model AssetSubscription {
  id        Int       @id @default(autoincrement())

  // Foreign Keys
  asset_id  Int
  user_id   Int

  subscription_type SubscriptionType

  createdAt DateTime @default(now()) @map("created_at")

  // Relations
  user  User  @relation(fields: [user_id], references: [id], onDelete: Cascade)
  asset Asset @relation(fields: [asset_id], references: [id], onDelete: Cascade)

  @@unique([asset_id, user_id]) // Prevent duplicate subscriptions to the same user-asset combo
  @@map("asset_subscriptions")
}

model PendingCommentNotification {
  id         Int @id @default(autoincrement())
  user_id    Int // Who the notification is for
  comment_id Int // Which comment it's associated with
  asset_id   Int // Which asset it's associated with

  // Whether user has dismissed this specific notification
  is_dismissed Boolean @default(false)

  createdAt DateTime @default(now()) @map("created_at")

  // Relations
  user    User         @relation(fields: [user_id], references: [id], onDelete: Cascade)
  comment AssetComment @relation(fields: [comment_id], references: [id], onDelete: Cascade)
  asset   Asset        @relation(fields: [asset_id], references: [id], onDelete: Cascade)

  @@unique([user_id, comment_id]) // One notification per user per comment
  @@map("pending_comment_notifications")
}

model AssetPendingLock {
  id            Int       @id @default(autoincrement())
  voteType      VoteType
  currentPhase  VotePhase
  asset_id      Int      @unique
  game_id       Int
  createdAt     DateTime @default(now()) @map("created_at")

  asset         Asset @relation(fields: [asset_id], references: [id], onDelete: Cascade)
  game          Game  @relation(fields: [game_id], references: [id], onDelete: Cascade)
}